---
title: 垃圾收集器与内存分配策略
date: 2021-10-10 18:51:42
permalink: /pages/139fd9/
categories:
  - JVM虚拟机专栏
  - 深入理解JVM
tags:
  - 
---
### 概述

Java 的内存区域中，程序计数器、虚拟机栈、本地方法站3个区域随线程而生，随线程而灭。这几个区域的内存具有确定性，不需要过多的考虑回收的问题，因为一个方法结束或者线程结束时，内存自然就跟着回收了。

Java 堆和方法区内存的分配和回收是动态的，只有在程序运行期间时才能知道需要创建哪些对象，垃圾收集器所关注的是这部分内存。



### 对象已死吗

#### 引用计数算法

给对象添加一个引用计数器，每当有一个地方引用该对象的时候，计数器值就加一；当引用失效的时候，计数器的值就减一；任何时刻当计数器的值为0的对象就是不可能在被使用的。它的特点如下：

- 实现简单，判定效率也很高；
- 很难解决对象之间循环引用的问题，会引起内存泄漏；
- 目前绝大多数的虚拟机都没有使用该方法

#### 可达性分析算法

从一系列被称为GC Roots 的对象为节点开始向下搜索，搜索所走过的路径称为引用链，当一个对象到GC Roots 没有任何引用链相连时，证明这个对象是不可用的。Java中可用作GC Roots 的对象包括下面几种：

- 虚拟机栈（栈帧中的本地变量表）中引用的对象
- 方法区中类静态属性引用的对象
- 方法区中常量引用的对象
- 本地方法栈中 JNI （即一般说的Native方法）引用的对象

#### 再谈引用

JDK1.2 之后Java对引用的概念进行了扩充，将引用分为强引用，软引用，弱引用，虚引用四种。

- 强引用：程序代码中普遍存在的，通过复制运算符“=”直接链接的引用关系，只要强引用还存在，垃圾回收器永远不会回收掉被引用的对象。
- 软引用：用来描述一些还有用但是非必须的对象。软引用关联着的对象，在系统将要发生内存溢出之前，会把这些对象列进回收范围之中进行二次回收。回收之后还是没有获取到足够的内存将会抛出异常，实现类SoftReference
- 弱引用：也是用来描述非必须对象的，但是其强度要比软引用更弱一些，被弱引用关联的对象只能生存到下一次垃圾收集发生之前。当垃圾收集器工作时无论内存是否充足，都会回收掉只被弱引用关联的对象。实现类WeakReference
- 虚引用：也被称为幽灵引用或幻影引用，最弱的一种引用关系。与对象的生存时间不会有一点影响，也不能通过虚引用获取对象实例。存在的目的是对象在被系统回收之前收到一个系统通知。实现类PhantomReference

#### 生存还是死亡

即使在可达性分析法中不可达的对象，也并非是一定要立即被回收的；在它被回收之前至少要经历两次标记过程：若发现一个对象被发现没有与GC Roots 相连接的引用链，将会被标记一次，并筛选出覆盖finalize()方法并且该方法没有被系统调用过的对象放入F-Queue中其他的回收掉，并在某一时刻执行finalize方法（该方法中可以进行自我拯救，把自己添加到GC Roots引用链中）稍后GC将对F-Queue 中的对象进行第二次标记，成功逃脱的对象将会被移除“即将回收”的集合，其他的对象被回收。Finalize()这个方法一般没人用。

#### 回收方法区

- 回收的对象：废弃常量和无用的类；
- 无用的类要求满足三个条件：
  - 该类的所有实例都已经被回收，也就是Java堆中不存在该类的实例
  - 加载该类的ClassLoader已经被回收掉
  - 该类对应的java.lang.Class 对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法
- 在大量使用反射，动态代理，CGLib等ByteCode框架，动态生成JSP以及OSGI这类频繁自定义ClassLoader的场景都需要虚拟机具备类卸载的功能，以保证永久代不会溢出。（Java 8 中已经用元空间替代永久代）



### 垃圾收集算法

#### 标记-清除算法

它是最基础的收集算法，后续的收集算法都是基于这种思路并对其不足进行改进而得到的。算法分为标记和清除两个阶段

- 标记出所有需要回收的对象
- 标记完统一回收

两个不足：

- 效率问题，标记和清除两个阶段的效率都不高
- 空间问题，标记清除后会产生大量不连续的内存碎片

#### 复制算法

将可用内存按照容量划分为大小相等的两块，每次只使用其中的一块。当一块的内存用完了，就将还存活着的对象复制到另一块上面，然后把已使用过的内存空间一次清理掉。实现简单，运行效率高，同时也解决了内存空间碎片的问题。

缺点：将内存缩小为原来的一半，内存利用率低。

现在的商用虚拟机都采用这种收集算法来回收新生代，而新生代的内存划分不是1:1 而是将内存分为一块较大的Eden空间和两块较小的Survivor空间，每次使用Eden 和其中一块Survivor 空间。当回收时，将Eden和Survivor 中还存活着的对象一次性的复制到另一块Survivor 空间上，最后清理掉Eden 和 刚才用过的Survivor空间。

HotSpot 虚拟机默认 Eden 和Survivor 的大小比例是 8:1.当Survivor 空间不够时，需要依赖其他内存（这里指老年代）进行分配担保。

#### 标记-整理算法

标记的过程和“标记-清除”算法一样，但后续步骤不是直接对可回收对象进行清理，而是让所有存活的对象都向一端移动，然后直接清除掉端边界以外的内存。

目的：解决复制算法在特定场景下的效率问题（老年代中的收集算法）

1. 对象存活率较高时，需要进行较多的复制操作，效率变低。
2. 如果不想浪费50%的空间需要进行分配担保，以应对被使用内存中所有的对象都存活的极端情况
3. 老年代一般不能直接选用这种算法

#### 分代收集算法

当前商业虚拟机的垃圾收集都采用“分代收集”算法。

根据对象存活周期的不同将内存划分为几块。一般是把Java 堆分为新生代和老年代，这样就可以根据各个年龄代的特点采用适当的收集算法。

新生代对象新生和死亡的对象很多，存活对象少选用‘复制算法’，老年代采用“标记清除”或“标记整理”算法。

### HotSpot 的算法实现

#### 枚举根节点

- 可达性分析法中的缺点
  - 耗时：从GC Roots 节点找引用链这个操作为例，可作为GC Roots 的节点主要有在全局的引用（如常量或类静态属性）与执行上下文（如栈帧中的本地变量表）中，现在很多应用仅仅方法区就有数百兆，如果要逐个检查这里的引用，那么一定会消耗很多时间。
  - 可达性分析对执行时间的敏感还体现在GC 停顿上，因为分析工作必须在一个能够保证同一执行的快照中进行，这是导致GC 进行时必须停顿所有的Java 线程（Stop The Word）的其中一个重要原因，即使是在号称不会发生停顿的CMS 收集器中枚举根节点时也是必须要停顿的。
- 目前主流的虚拟机使用的都是准确式GC，所以当执行系统停顿下来后，并不需要一个不漏的检查完所有执行上下文和全局的引用位置，虚拟机当然有办法直接得知哪些地方存放着对象引用。HotSpot 虚拟机中使用一组称为OopMap 的数据结构来达到目的，在类加载完成的时候，HotSpot 就把对象内什么偏移量上是什么类型的数据计算出来，在JIT 编译过程中，也会在特定的位置记录下栈和寄存器中哪些位置是引用。这样，GC 在扫描时就可以直接得知这些信息了。

#### 安全点

HotSpot 虚拟机不可能为每一条指令都生成对应的OopMap，那样的话会需要大量的额外空间。只有在安全点才会生成对应的OopMap。

实际上，HotSpot也的确没有为每条指令都生成OopMap，只是在“特定的位置”记录了这些信息，这些位置称为安全点（Safepoint）程序执行时并非在所有地方都能停顿下来开始GC，只有在到达安全点时才能暂停。Safepoint的选定既不能太少以致于让GC等待时间太长，也不能过于频繁以致于过分增大运行时的负荷。所以，安全点的选定基本上是以程序“是否具有让程序长时间执行的特征”为标准进行选定的——因为每条指令执行的时间都非常短暂，程序不太可能因为指令流长度太长这个原因而过长时间运行，“长时间执行”的最明显特征就是指令序列复用，例如方法调用、循环跳转、异常跳转等，所以具有这些功能的指令才会产生Safepoint。

这些特定的位置主要在：

1. 循环的末尾
2. 方法临返回前 / 调用方法的call指令后
3. 可能抛异常的位置

- 对于安全点另一个要考虑的问题是如何在GC 发生时让所有线程（不包括这行JNI 调用的线程）都执行到最近的安全点上再停顿下来。这里有两种方案可选：
  - 抢先式中断：不需要线程的执行代码去配合，在GC 发生时，首先把所有线程全部中断，如果发现有线程不在安全点上，就恢复线程，让它运行到安全点上。现在几乎没有虚拟机实现采用抢先式中断来暂停线程从而响应GC事件。
  - 主动式中断：当GC 需要中断线程的时候，不直接对线程操作，仅仅简单的设置一个表示，各个线程执行时主动去轮询这个标志，发现中断标志为真时就自己中断挂起。轮询标志的地方和安全点是重合的。

#### 安全区域

Selfpoint 机制保证了程序执行时，在不太长的时间内就会遇到可进入GC 的Safe point。在程序不执行，没有分配CPU 时间，典型的例子就是线程处于Sleep 状态或者Blocked 状态，这个时候线程无法响应JVM 的中断请求，执行到安全的地方去中断挂起，JVM 也显然不太可能等待线程重新被分配CPU 时间。需要安全区域来解决这个问题。

安全区域是在一段代码片段之中，引用关系不会发生变化。在这个区域中的任意地方开始GC 都是安全的。

在线程执行到安全区域中的代码时，首先标识自己已经进入了safe region 当这段时间里JVM 要发起 GC 时，就不用管标识自己为Safe Region 状态的线程了。在线程要离开Safe Region 时，它要检查系统是否已经完成了根节点枚举（或者是整个GC 过程），如果完成了，那线程就继续执行，否则它就必须等待直到收到可以安全离开Safe Region 的信号为止。

