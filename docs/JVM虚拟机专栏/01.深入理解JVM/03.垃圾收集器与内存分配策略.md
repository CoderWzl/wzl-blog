---
title: 垃圾收集器与内存分配策略
date: 2021-10-10 18:51:42
permalink: /pages/139fd9/
categories:
  - JVM虚拟机专栏
  - 深入理解JVM
tags:
  - 
---
### 概述

Java 的内存区域中，程序计数器、虚拟机栈、本地方法站3个区域随线程而生，随线程而灭。这几个区域的内存具有确定性，不需要过多的考虑回收的问题，因为一个方法结束或者线程结束时，内存自然就跟着回收了。

Java 堆和方法区内存的分配和回收是动态的，只有在程序运行期间时才能知道需要创建哪些对象，垃圾收集器所关注的是这部分内存。



### 对象已死吗

#### 引用计数算法

给对象添加一个引用计数器，每当有一个地方引用该对象的时候，计数器值就加一；当引用失效的时候，计数器的值就减一；任何时刻当计数器的值为0的对象就是不可能在被使用的。它的特点如下：

- 实现简单，判定效率也很高；
- 很难解决对象之间循环引用的问题，会引起内存泄漏；
- 目前绝大多数的虚拟机都没有使用该方法

#### 可达性分析算法

从一系列被称为GC Roots 的对象为节点开始向下搜索，搜索所走过的路径称为引用链，当一个对象到GC Roots 没有任何引用链相连时，证明这个对象是不可用的。Java中可用作GC Roots 的对象包括下面几种：

- 虚拟机栈（栈帧中的本地变量表）中引用的对象
- 方法区中类静态属性引用的对象
- 方法区中常量引用的对象
- 本地方法栈中 JNI （即一般说的Native方法）引用的对象

#### 再谈引用

JDK1.2 之后Java对引用的概念进行了扩充，将引用分为强引用，软引用，弱引用，虚引用四种。

- 强引用：程序代码中普遍存在的，通过复制运算符“=”直接链接的引用关系，只要强引用还存在，垃圾回收器永远不会回收掉被引用的对象。
- 软引用：用来描述一些还有用但是非必须的对象。软引用关联着的对象，在系统将要发生内存溢出之前，会把这些对象列进回收范围之中进行二次回收。回收之后还是没有获取到足够的内存将会抛出异常，实现类SoftReference
- 弱引用：也是用来描述非必须对象的，但是其强度要比软引用更弱一些，被弱引用关联的对象只能生存到下一次垃圾收集发生之前。当垃圾收集器工作时无论内存是否充足，都会回收掉只被弱引用关联的对象。实现类WeakReference
- 虚引用：也被称为幽灵引用或幻影引用，最弱的一种引用关系。与对象的生存时间不会有一点影响，也不能通过虚引用获取对象实例。存在的目的是对象在被系统回收之前收到一个系统通知。实现类PhantomReference

#### 生存还是死亡

即使在可达性分析法中不可达的对象，也并非是一定要立即被回收的；在它被回收之前至少要经历两次标记过程：若发现一个对象被发现没有与GC Roots 相连接的引用链，将会被标记一次，并筛选出覆盖finalize()方法并且该方法没有被系统调用过的对象放入F-Queue中其他的回收掉，并在某一时刻执行finalize方法（该方法中可以进行自我拯救，把自己添加到GC Roots引用链中）稍后GC将对F-Queue 中的对象进行第二次标记，成功逃脱的对象将会被移除“即将回收”的集合，其他的对象被回收。Finalize()这个方法一般没人用。

#### 回收方法区

- 回收的对象：废弃常量和无用的类；
- 无用的类要求满足三个条件：
  - 该类的所有实例都已经被回收，也就是Java堆中不存在该类的实例
  - 加载该类的ClassLoader已经被回收掉
  - 该类对应的java.lang.Class 对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法
- 在大量使用反射，动态代理，CGLib等ByteCode框架，动态生成JSP以及OSGI这类频繁自定义ClassLoader的场景都需要虚拟机具备类卸载的功能，以保证永久代不会溢出。（Java 8 中已经用元空间替代永久代）



### 垃圾收集算法

#### 标记-清除算法

它是最基础的收集算法，后续的收集算法都是基于这种思路并对其不足进行改进而得到的。算法分为标记和清除两个阶段

- 标记出所有需要回收的对象
- 标记完统一回收

两个不足：

- 效率问题，标记和清除两个阶段的效率都不高
- 空间问题，标记清除后会产生大量不连续的内存碎片

#### 复制算法

将可用内存按照容量划分为大小相等的两块，每次只使用其中的一块。当一块的内存用完了，就将还存活着的对象复制到另一块上面，然后把已使用过的内存空间一次清理掉。实现简单，运行效率高，同时也解决了内存空间碎片的问题。

缺点：将内存缩小为原来的一半，内存利用率低。

现在的商用虚拟机都采用这种收集算法来回收新生代，而新生代的内存划分不是1:1 而是将内存分为一块较大的Eden空间和两块较小的Survivor空间，每次使用Eden 和其中一块Survivor 空间。当回收时，将Eden和Survivor 中还存活着的对象一次性的复制到另一块Survivor 空间上，最后清理掉Eden 和 刚才用过的Survivor空间。

HotSpot 虚拟机默认 Eden 和Survivor 的大小比例是 8:1.当Survivor 空间不够时，需要依赖其他内存（这里指老年代）进行分配担保。

#### 标记-整理算法

标记的过程和“标记-清除”算法一样，但后续步骤不是直接对可回收对象进行清理，而是让所有存活的对象都向一端移动，然后直接清除掉端边界以外的内存。

目的：解决复制算法在特定场景下的效率问题（老年代中的收集算法）

1. 对象存活率较高时，需要进行较多的复制操作，效率变低。
2. 如果不想浪费50%的空间需要进行分配担保，以应对被使用内存中所有的对象都存活的极端情况
3. 老年代一般不能直接选用这种算法

#### 分代收集算法

当前商业虚拟机的垃圾收集都采用“分代收集”算法。

根据对象存活周期的不同将内存划分为几块。一般是把Java 堆分为新生代和老年代，这样就可以根据各个年龄代的特点采用适当的收集算法。

新生代对象新生和死亡的对象很多，存活对象少选用‘复制算法’，老年代采用“标记清除”或“标记整理”算法。

### HotSpot 的算法实现

#### 枚举根节点

- 可达性分析法中的缺点
  - 耗时：从GC Roots 节点找引用链这个操作为例，可作为GC Roots 的节点主要有在全局的引用（如常量或类静态属性）与执行上下文（如栈帧中的本地变量表）中，现在很多应用仅仅方法区就有数百兆，如果要逐个检查这里的引用，那么一定会消耗很多时间。
  - 可达性分析对执行时间的敏感还体现在GC 停顿上，因为分析工作必须在一个能够保证同一执行的快照中进行，这是导致GC 进行时必须停顿所有的Java 线程（Stop The Word）的其中一个重要原因，即使是在号称不会发生停顿的CMS 收集器中枚举根节点时也是必须要停顿的。
- 目前主流的虚拟机使用的都是准确式GC，所以当执行系统停顿下来后，并不需要一个不漏的检查完所有执行上下文和全局的引用位置，虚拟机当然有办法直接得知哪些地方存放着对象引用。HotSpot 虚拟机中使用一组称为OopMap 的数据结构来达到目的，在类加载完成的时候，HotSpot 就把对象内什么偏移量上是什么类型的数据计算出来，在JIT 编译过程中，也会在特定的位置记录下栈和寄存器中哪些位置是引用。这样，GC 在扫描时就可以直接得知这些信息了。

#### 安全点

HotSpot 虚拟机不可能为每一条指令都生成对应的OopMap，那样的话会需要大量的额外空间。只有在安全点才会生成对应的OopMap。

实际上，HotSpot也的确没有为每条指令都生成OopMap，只是在“特定的位置”记录了这些信息，这些位置称为安全点（Safepoint）程序执行时并非在所有地方都能停顿下来开始GC，只有在到达安全点时才能暂停。Safepoint的选定既不能太少以致于让GC等待时间太长，也不能过于频繁以致于过分增大运行时的负荷。所以，安全点的选定基本上是以程序“是否具有让程序长时间执行的特征”为标准进行选定的——因为每条指令执行的时间都非常短暂，程序不太可能因为指令流长度太长这个原因而过长时间运行，“长时间执行”的最明显特征就是指令序列复用，例如方法调用、循环跳转、异常跳转等，所以具有这些功能的指令才会产生Safepoint。

这些特定的位置主要在：

1. 循环的末尾
2. 方法临返回前 / 调用方法的call指令后
3. 可能抛异常的位置

- 对于安全点另一个要考虑的问题是如何在GC 发生时让所有线程（不包括这行JNI 调用的线程）都执行到最近的安全点上再停顿下来。这里有两种方案可选：
  - 抢先式中断：不需要线程的执行代码去配合，在GC 发生时，首先把所有线程全部中断，如果发现有线程不在安全点上，就恢复线程，让它运行到安全点上。现在几乎没有虚拟机实现采用抢先式中断来暂停线程从而响应GC事件。
  - 主动式中断：当GC 需要中断线程的时候，不直接对线程操作，仅仅简单的设置一个表示，各个线程执行时主动去轮询这个标志，发现中断标志为真时就自己中断挂起。轮询标志的地方和安全点是重合的。

#### 安全区域

Selfpoint 机制保证了程序执行时，在不太长的时间内就会遇到可进入GC 的Safe point。在程序不执行，没有分配CPU 时间，典型的例子就是线程处于Sleep 状态或者Blocked 状态，这个时候线程无法响应JVM 的中断请求，执行到安全的地方去中断挂起，JVM 也显然不太可能等待线程重新被分配CPU 时间。需要安全区域来解决这个问题。

安全区域是在一段代码片段之中，引用关系不会发生变化。在这个区域中的任意地方开始GC 都是安全的。

在线程执行到安全区域中的代码时，首先标识自己已经进入了safe region 当这段时间里JVM 要发起 GC 时，就不用管标识自己为Safe Region 状态的线程了。在线程要离开Safe Region 时，它要检查系统是否已经完成了根节点枚举（或者是整个GC 过程），如果完成了，那线程就继续执行，否则它就必须等待直到收到可以安全离开Safe Region 的信号为止。

### 垃圾收集器

重点在于不同垃圾收集器的特点，从所处分代年龄，算法实现和并发的支持等方面进行考虑。

#### Serial 收集器

- 单一线程，使用一个CPU或一条收集线程去完成垃圾收集工作，更重要的是在它进行垃圾收集时，必须暂停其他所有的工作线程，直到它结束。
- 占用内存小，虚拟机在Client模式下的默认新生代收集器
- 采用复制算法
- 新生代的收集器

#### ParNew 收集器

- 是Serial 收集器的多线程版本，除了使用多线程进行垃圾收集之外，其余行为包括Serial 收集器所有控制参数，收集算法，Stop The Word，对象分配规则，回收策略等都与Serial 收集器完全一致。
- 许多运行在Server     模式下的虚拟机中首选的新生代收集器，其中一个重要的原因是目前只有它能够与CMS 收集器配合工作。
- 复制算法
- 新生代中的收集器
- 在单核处理器中不能获得比Serial 更高的性能

#### Parallel Scavenge 收集器

- 也是使用复制算法的收集器
- 又是并行的多线程收集器
- 与其他收集器的区别在于关注点不同，CMS等收集器的关注点是尽可能的缩短垃圾收集时用户线程停顿时间，而Parallel Scavenge 收集器的目标是达到一个可控制的吞吐量
  - 吞吐量：CPU 用于运行用户代码的时间与 CPU 总消耗时间的比值。即吞吐量 = 运行用户代码时间 / （运行用户代码时间 + 垃圾收集时间）
  - 当吞吐量很大会导致GC 更加频繁，这一点不难想到。
  - Parallel Scavenge 收集器与吞吐量关系密切，所以也常被称为“吞吐量优先”收集器
- 自适应调节策略也是 Parallel     Scavenge 收集器与 ParNew 收集器的一个重要区别。
  - 打开-XX:UseAdapteiveSizePolicy参数就不需要手工指定新生代的大小，Eden 与 Survivor 区的比例，晋升老年代对象的大小等细节参数（参数的具体信息不列举出来，课本可查。）了。虚拟机会根据当前系统的？云从？情况收集性能监控信息，动态调整这些参数以一共最合适的停顿时间或者最大的吞吐量。
- 新生代中的收集器

#### Serial Old 收集器

- Serial 收集器的老年代版本
- 单线程收集器
- 标记-整理 算法
- 主要意义也是在于给 Client 模式下的虚拟机使用
- 还有两大用途：
  - JDK1.5 以及之前的版本中与Parallel Scavenge 收集器搭配使用
  - 作为CMS 收集器的后备预案，在并发收集发生Concurrent Mode Failure 时使用。

#### Parallel Old 收集器

- Parallel Old 是 Parallel Scavenge 收集器的老年代版本
- 多线程收集器
- 标记-整理 算法

#### CMS 收集器（Concurrent Mark Sweep）

- 是一种以获取最短回收停顿时间为目标的收集器。
- 使用的是“标记-清除”算法实现的
- 运作过程分为4个步骤：
  1. 初始标记：需要Stop The World，仅仅标记一下GC Roots 能直接关联到的对象，速度快
  2. 并发标记：并发标记阶段就是进行GC Roots Tracing 的过程
  3. 重新标记：修正并发标记期间因用户程序继续运作而导致标记产生变动的那一部分对象的标记记录，耗时比初始标记稍长
  4. 并发清除：收集过程中耗时最长的并发标记和并发清除过程收集线程都可以与用户线程一起工作。
- 优点：并发收集，低停顿
- 缺点：
  - CMS 收集器对 CPU 资源非常敏感。“增量式并发收集器”的CMS 收集器变种来解决这个问题
  - CMS 收集器无法处理浮动垃圾（GC 过程中产生的垃圾），可能出现“Concurrent Mode Faolure”失败而导致另一次 FullGC 的产生。
  - 标记-清除算法实现的收集器，收集结束时会产生大量的空间碎片。

#### G1收集器

- 当前收集器技术发展的最前沿成果之一
- 一款面向服务端的垃圾收集器
- 具备如下特点：
  - 并行与并发：使用多个CPU 来缩短 Stop The     Word 停顿时间
  -  分代收集：管理整个堆，但是对新生代和老年代有不同的处理方式
  - 空间整合：整体来看基于“标记-整理”算法，局部来看基于“复制算法”。
  - 可预测的停顿
- 之前的收集器收集的范围都是整个新生代或者老年代，G1 保留了新生代和老年代的概念，但新生代和老年代不在是物理隔离的了，他们是一部分 Region 的集合
- G1 收集器之所以能够建立可预测的停顿时间模型，因为它可以有计划的避免在整个Java堆中进行全区域的垃圾收集。
- G1 收集器中， Regin 之间的对象引用以及其他收集器中的新生代与老年代之间的对象引用，虚拟机都是使用Remembered Set 来避免全堆扫描的。
- G1 收集器的运作分为以下几个步骤：
  1. 初始标记：只是标记一下 GC Roots 能直接关联到的对象，并修改TAMS（Next Top at Mark Start）的值，让下一阶段用户程序并发运行时，能在正确可用的 Region 中创建对象，这个阶段需要停顿线程，但是耗时很短
  2. 并发标记：从GC Roots 开始对堆中对象进行可达性分析，找出存活对象，耗时长，可与用户程序并发执行
  3. 最终标记：修正在并发标记期间因用户程序继续运行而导致标记产生变动的那一部分标记记录
  4. 筛选回收

#### 理解 GC 日志：（不做重点，使用时查看）

#### 内存分配与回收策略

- 对象优先在 Eden 分配
- 大对象直接进入老年代
- 长期存活的对象将进入老年代
- 动态对象年龄判定
- 空间分配担保
