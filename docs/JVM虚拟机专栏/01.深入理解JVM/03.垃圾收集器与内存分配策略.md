---
title: 垃圾收集器与内存分配策略
date: 2021-10-10 18:51:42
permalink: /pages/139fd9/
categories:
  - JVM虚拟机专栏
  - 深入理解JVM
tags:
  - 
---
### 概述

Java 的内存区域中，程序计数器、虚拟机栈、本地方法站3个区域随线程而生，随线程而灭。这几个区域的内存具有确定性，不需要过多的考虑回收的问题，因为一个方法结束或者线程结束时，内存自然就跟着回收了。

Java 堆和方法区内存的分配和回收是动态的，只有在程序运行期间时才能知道需要创建哪些对象，垃圾收集器所关注的是这部分内存。



### 对象已死吗

#### 引用计数算法

给对象添加一个引用计数器，每当有一个地方引用该对象的时候，计数器值就加一；当引用失效的时候，计数器的值就减一；任何时刻当计数器的值为0的对象就是不可能在被使用的。它的特点如下：

- 实现简单，判定效率也很高；
- 很难解决对象之间循环引用的问题，会引起内存泄漏；
- 目前绝大多数的虚拟机都没有使用该方法

#### 可达性分析算法

从一系列被称为GC Roots 的对象为节点开始向下搜索，搜索所走过的路径称为引用链，当一个对象到GC Roots 没有任何引用链相连时，证明这个对象是不可用的。Java中可用作GC Roots 的对象包括下面几种：

- 虚拟机栈（栈帧中的本地变量表）中引用的对象
- 方法区中类静态属性引用的对象
- 方法区中常量引用的对象
- 本地方法栈中 JNI （即一般说的Native方法）引用的对象

#### 再谈引用

JDK1.2 之后Java对引用的概念进行了扩充，将引用分为强引用，软引用，弱引用，虚引用四种。

- 强引用：程序代码中普遍存在的，通过复制运算符“=”直接链接的引用关系，只要强引用还存在，垃圾回收器永远不会回收掉被引用的对象。
- 软引用：用来描述一些还有用但是非必须的对象。软引用关联着的对象，在系统将要发生内存溢出之前，会把这些对象列进回收范围之中进行二次回收。回收之后还是没有获取到足够的内存将会抛出异常，实现类SoftReference
- 弱引用：也是用来描述非必须对象的，但是其强度要比软引用更弱一些，被弱引用关联的对象只能生存到下一次垃圾收集发生之前。当垃圾收集器工作时无论内存是否充足，都会回收掉只被弱引用关联的对象。实现类WeakReference
- 虚引用：也被称为幽灵引用或幻影引用，最弱的一种引用关系。与对象的生存时间不会有一点影响，也不能通过虚引用获取对象实例。存在的目的是对象在被系统回收之前收到一个系统通知。实现类PhantomReference

#### 生存还是死亡

即使在可达性分析法中不可达的对象，也并非是一定要立即被回收的；在它被回收之前至少要经历两次标记过程：若发现一个对象被发现没有与GC Roots 相连接的引用链，将会被标记一次，并筛选出覆盖finalize()方法并且该方法没有被系统调用过的对象放入F-Queue中其他的回收掉，并在某一时刻执行finalize方法（该方法中可以进行自我拯救，把自己添加到GC Roots引用链中）稍后GC将对F-Queue 中的对象进行第二次标记，成功逃脱的对象将会被移除“即将回收”的集合，其他的对象被回收。Finalize()这个方法一般没人用。

#### 回收方法区

- 回收的对象：废弃常量和无用的类；
- 无用的类要求满足三个条件：
  - 该类的所有实例都已经被回收，也就是Java堆中不存在该类的实例
  - 加载该类的ClassLoader已经被回收掉
  - 该类对应的java.lang.Class 对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法
- 在大量使用反射，动态代理，CGLib等ByteCode框架，动态生成JSP以及OSGI这类频繁自定义ClassLoader的场景都需要虚拟机具备类卸载的功能，以保证永久代不会溢出。（Java 8 中已经用元空间替代永久代）



### 垃圾收集算法

#### 标记-清除算法

它是最基础的收集算法，后续的收集算法都是基于这种思路并对其不足进行改进而得到的。算法分为标记和清除两个阶段

- 标记出所有需要回收的对象
- 标记完统一回收

两个不足：

- 效率问题，标记和清除两个阶段的效率都不高
- 空间问题，标记清除后会产生大量不连续的内存碎片

#### 复制算法

