### 概述

虚拟机把描述类的数据从Class 文件加载到内存，并对数据进行校验、转换解析和初始化，最终形成可以被虚拟机直接使用的Java 类型，这就是虚拟机的类加载机制。

类型的加载、链接和初始化过程都是在程序运行期间完成的。Java 可以动态扩展的语言特性就是依赖运行期动态加载和动态链接这个特点实现的。

### 类加载的时机

类从被虚拟机加载到内存中开始，直到卸载出内存为止，整个生命周期包括：加载、验证、准备、解析、初始化、使用、卸载7个阶段，其中验证、准备、解析3个部分称为连接。

类的加载、验证、准备、初始化、卸载这5个阶段会按部就班的开始（相互交叉地混合式进行的），而解析阶段不一定，某些情况下可以在初始化阶段之后再进行。

虚拟机规定了有且只有5种情况必须对类进行“初始化”（加载、验证、准备自然需要在此之前）

1. 遇到 new、getstatic、putstatic、invokestatic这四条字节码指令的时候，如果类没有进行过初始化，需要先触发其初始化。
2. 使用     java.lang.reflect 包的方法对类进行反射调用的时候，如果类没有进行过初始化，则需要先触发其初始化。
3. 当初始化一个类的时候，如果发现其父类还没有进行初始化，则需要先对其父类进行初始化。
4. 当虚拟机启动的时候，用户需要指定一个要执行的主类（包含了main 方法的类），虚拟机会先初始化这个类。
5. 当使用JDK1.7     的动态语言支持时，如果一个 java.lang.invoke.MethodHanle     实例最后的解析结果REF_getstatic、REF_putstatic、REF_invokestatic 的方法句柄，并且这个方法句柄所对应的类没有进行初始化，则需要先触发其初始化。

只有上面5 种行为会触发类的初始化，称为对一个类进行主动引用，除此之外，所有引用类的方式都不会触发初始化，称为被动引用。示例如下：

1. 通过字类引用父类的静态字段，不会导致子类初始化
2. 通过数组定义来引用类，不会触发此类的初始化，如     com.test.A[] a = new A[5] 不会对A类进行初始化，但是会触发 [com.test.A 的类的初始化，它是由虚拟机自动生成的直接继承Object 的字类，创建动作由字节码指令newarray 触发。
3. 常量在编译阶段会存入调用类的常量池中，不会触发初始化。

接口的加载过程与类的加载过程有一些不同：接口也有初始化过程，接口种不能使用 static{} 语句块但是编译器仍会为接口生成“\<clinit>”类构造器，用于初始化接口中所定义的成员变量。

当一个类在初始化时，要求其父类全部都已经初始化过了，但是一个接口在初始化的时候，并不要求其父接口全部初始化只有在正真使用到父类接口的时候（如引用接口中定义的常量）才会初始化。

### 类加载过程

##### 加载

加载是类加载过程的一个阶段，加载阶段，虚拟机需要完成以下3 件事：

1. 通过一个类的全限定名来获取定义此类的二进制字节流。
2. 将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构。
3. 在内存中生成一个代表这个类的 java.lang.Class 对象。作为方法区这个类的各种数据的访问入口。

通过一个类的全限定名来获取定义此类的二进制字节流，没有指明流必须从一个Class文件获取，可以从zip 包中获取 jar、ear、war 格式的基础，网络获取，运行时计算生成，其他文件生成jsp…

- 用户可以自定义类加载器去完成加载，开发人员也可以通过自定义自己的类加载器去控制字节流的获取方式（重写类加载器的 loadClass 方法）
- 数组的创建不通过类加载器，由Java 虚拟机直接创建的。创建过程遵循以下规则：
  1. 数组的组件类型（去掉一个维度之后的类型）是引用类型，就递归采用本节自定义的加载器去加载这个组件类型，数组将在加载该组件类型的类加载器的类名称空间上被标识。
  2. 如果数组的组件类型不是引用类型，Java     虚拟机将会把数组标记为与引导类加载器关联。
  3. 数组类的可见性与它的组件类型的可见性一致，如果组件类型不是引用类型，那数组类的可见性将默认为public。
- 加载阶段完成后，虚拟机外部的二进制字节流就按照虚拟机所需要的存储格式存储在方法区之中，方法区中的数据存储格式由虚拟机实现自行定义，虚拟机规范未定义此区域的具体数据结构。然后在内存中实例化一个 java.lang.Class类的对象（不一定在堆中，HotSport 中存储在方法区中），这个对象将作为程序访问方法区中的这些类型数据的外部接口。
- 加载阶段与连接阶段的部分内容是交叉进行的，但开始时间仍然保持着固定的先后顺序。

##### 验证

链接的第一步，确保 Class 文件的字节流中包含的信息符合当前虚拟机的要求，并且不会危害虚拟机自身的安全。

验证阶段大致上分为下面4个阶段的检验动作：文件格式验证，元数据验证，字节码验证，符号引用验证。

- 文件格式验证：验证字节流是否符合 Class 文件格式规范，并且能被当前版本的虚拟机正确处理。

  1. 魔术 0xCAFEBABE
  2. 主、次版本号是否在当前虚拟机处理范围内
  3. 常量池的常量中是否有不被支持的常量类型（检查常量tag标志）
  4. 指向常量的各种索引值是否有指向不存在的常量或不符合类型的常量
  5. CONSTANT_Utf_info     型的常量中是否有不符合UTF8 编码的数据。
  6. Class     文件中各个部分及文件本身是否有被删除的或附加的其他信息。
  7. 。。。

  该验证阶段的主要目的是保证输入的字节流能正确的解析并存储于方法区之内，后面3个验证阶段全部是基于方法区的存储结构进行的，不会再操作字节流。

- 元数据验证：对字节码描述的信息进行语义分析，保证其描述的信息符合 Java 语言规范的要求

  - 该类是否有父类
  - 该类是否继承了不被允许继承的类
  - 不是抽象类是否实现接口或父类的抽象方法。
  - 类中的字段，方法是否与父类产生矛盾

- 字节码验证：最复杂的阶段，主要目的是通过数据流和控制流分析，确定程序予以是合法的、符合逻辑的。对类的方法体进行校验分析

  - 保证任意时刻操作数栈的数据类型与指令代码都能配合工作（类型匹配）
  - 保证跳转指令不会跳转到方法体之外的字节码指令上
  - 保证方法体中的类型转换是有效的。

  通过程序去校验程序逻辑是无法做到绝对准确的--不能通过程序准确的检查出程序是否能在有限的时间之内结束运行。

- 符号引用：该阶段发生在虚拟机将符号引用转化为直接引用的时候，这个转化动作将在链接的第三阶段--解析阶段中发生

  - 符号引用中通过字符描述的全限定名是否能找到对用的类。
  - 在指定类中是否存在符合方法的字段描述符以及简单名称所描述的方法和字段。
  - 符号引用中的类，字段，方法的访问性是否可被当前类访问。

  符号引用验证的目的是确保解析动作能正常执行。

##### 准备

准备阶段是正式为类变量分配内存并设置类变量初始值的阶段，这些变量所使用的内存都将在方法区中进行分配。

两个容易产生混淆的概念：

1. 这个时候进行内存分配仅包括类变量，而不包括实例变量，实例对象将在对象实例化时随对象一起分配在 Java 堆中。
2. 初始值‘通常情况下’是数据的零值，因为这个时候还未执行任何 Java 方法，为静态变量赋预先设置的初值的指令putstatic 是程序被编译后，存放在类构造器     \<clinit>() 方法之中，所以会在类的初始化阶段才会赋上预想的值。
3. 特殊情况是 final 修饰的类变量会存在 ConstantValue 属性，准备阶段变量将会被直接赋值程序猿设定的目标初始值而非零值。

##### 解析

解析阶段是虚拟机将常量池内的符号引用替换为直接引用的过程

符号引用和直接引用有什么关联？

1. 符号引用：以一组符号来描述所引用的目标，符号可以是任意形式的字面量，只要能无歧义的定位到目标即可。符号引用与虚拟机的内存布局无关，引用的目标目标不一定已经加载到内存了。各种虚拟机的内存布局可以不同但是他们能够接受的符号引用必须都是一致的，因为符号引用的字面量形式明确定义在 Java 虚拟机规范的 Class 文件格式中。
2. 直接引用：可以是直接指向目标的指针、相对偏移量或是一个能间接定位到目标的句柄。和虚拟机实现的内存布局相关，同一个符号引用在不同的虚拟机实现上翻译出来的直接引用一般不会相同。有了直接引用那么被引用的目标一定已经在内存中存在。

虚拟机规范中并未规定解析阶段发生的具体时间，只要求了在执行 anewarray、checkcast、getfield、getstatic、instanceof、invokedynamic、invokeinterface、invokespecial、invokestatic、invokevirtual、ldc、ldc_w、multianewarray、new、putfield、和putstatic 这16个用于操作符号引用的字节码指令之前，先对他们所使用的符号引用进行解析。

除 invokedynamic 指令外，虚拟机实现可以对第一次解析的结果进行缓存（运行时常量池中记录直接引用，并把常量标识为已解析的状态）避免解析动作重复进行。

解析动作主要针对类或接口、字段、类方法、接口方法、方法类型、方法句柄和调用点限定符7类符号引用进行，分别对应于常量池的     CONSTANT_Class_info、CONSTANT_Fieldref_info、CONSTANT_Methodref_info、CONSTANT_IntefaceMethodref_info、CONSTANT_MethodType_info、CONSTANT_MethodHandle_info 和 CONSTANT_InvokeDynamic_info 7 中常量。

- 类或接口的解析

  假设当前代码所处的类为D，如果要把一个从未解析过的符号引用 N 解析为一个类或接口 C 的直接引用，那虚拟机完成整个解析的过程需要以下 3 个步骤：

  1. 如果 C 不是一个数组类型，那虚拟机将会把代表 N 的全限定名传递给 D 的类加载器去加载这个类 C。加载过程中，由于元数据、字节码验证的需要、又可能触发其他相关的加载动作。一旦这个过程中出现任何异常，解析过程就宣告失败。
  2. 如果 C 是一个数组类型，并且数组的元素类型为对象，也就是 N 的全限定名会类似‘[Ljava/lang/Integer’的形式，会先按照第1条的规则加载数组元素类型。接着由虚拟机生成一个代表此数组维度和元素的数组对象。
  3. 如果上面步骤没有出现任何问题，C 在虚拟机中实际上已经成为一个有效的类或接口了。解析完成之后还要进行符号引用验证，确认 D 是否具备对 C 的访问权限。不具备访问权限的话抛出 java.lang.IllegalAccessError 异常。

- 字段解析

  要解析一个未被解析过的字段符号引用，首先会将字段表内 class_index 项中索引的 CONSTANT_Class_info 符号引用进行解析，也就是字段所属的类或接口的符号引用。如果解析这个类或接口符号引用的过程中出现了任何异常，都会导致字段符号引用解析失败。成功解析的类或接口用 C 表示，虚拟机规范要求如下步骤对 C 进行后续字段的搜索：

  1. 如果 C 本身就包含了简单名称和字段描述符都与目标相匹配的字段，则返回这个字段的直接引用，查找结束。
  2. 否则，如果在 C 中实现了接口，将会按照继承关系从下往上递归搜索各个接口和它的父接口，如果接口中包含了简单名称和字段描述符都与目标相匹配的字段，则返回这个字段的直接引用，查找结束。
  3. 否则，如果 C 不是 Object 的话，将按照继承关系从下往上递归搜索其父类，若父类中包含了简单名称和字段描述符都与目标匹配的字段，则返回这个字段的直接引用，查找结束。
  4. 否则查找失败，抛出 java.lang.NoSuchFieldError 异常。

- 类方法解析：

  类方法解析的第一步与字段解析一样，需要先解析出类方法表的 class_index 项中索引的方法所属的类或接口的符号引用，如果解析成功，用 C 表示这个类，接着按照如下步骤进行方法搜索：

  1. 类方法和接口方法符号引用的常量类型定义是分开的，在类方法表中发现 class_index     中索引的 C 是一个接口，那就直接抛出IncompatibleClassChangeError。
  2. 通过了第一步，在类 C     中查找是否有简单名称和描述符都与目标相匹配的方法，如果有则返回这个方法的直接引用，查找结束。
  3. 否则在 类 C     的父类中递归查找是否有简单名称和描述符都与目标相匹配的方法，有则直接返回方法的直接引用
  4. 否则在类 C     实现的接口列表及他们的父接口中递归查找是否有简单名称和描述符都与目标相匹配的方法，如果有说明类C 是一个抽象类，这是查找结束，抛出AbstractMethodError 异常
  5. 否则方法查找失败，抛出NoSuchMethodError 异常。

  成功返回方法的直接引用后将进行权限验证，不具备对此方法的访问权限抛出IllegalAccessError 异常。

- 接口方法解析：

  接口方法也需要先解析出接口方法表的 class_index 项中索引的方法所属的类或接口的符号引用。成功解析后用 C 来表示此接口，进行后续步骤的方法搜索。

  1. 在接口方法表中发现 class_index 中的索引 C 是个类而不是接口，就直接抛出IncompatibleClssChangeError 异常。
  2. 否则在接口 C     中查找是否有简单名称和描述符都与目标接口方法相匹配的方法，有则直接返回这个方法的直接引用。
  3. 否则在 C     的父接口中递归查找，知道Object 类为止，有简单名称和描述符都与目标相匹配的方法，则直接返回该方法的直接引用。
  4. 否则，查找失败，抛出NoSuchMethodError 异常。

  接口中的方法访问权限都是public 的，不存在访问权限的检查，不会抛出 IllegalAccessError 异常。

##### 初始化

类初始化阶段是类加载过程的最后一步，前面的类加载过程中，除了在加载阶段用户应用程序可以通过自定义类加载器参与之外，其余动作完全由虚拟机主导和控制。到了初始化阶段，才真正开始执行类中自定义的 Java 程序代码（或者说是字节码）。

在准备阶段，变量已经赋过一次系统要求的初始值，而在初始化阶段，则根据程序员通过程序制定的主观计划去初始化类变量和其他资源。

初始化阶段是执行类构造器\<clinit>() 方法的过程。\<clinit>() 方法的特点和细节。

1. 由编译器自动收集类中的所有类变量的复制动作和静态代码块中的语句合并产生的，收集的顺序是由语句在源文件中出现的顺序所决定的。静态代码块中只能访问到定义在静态代码块之前的变量。
2. \<clinit>()方法与类的构造函数（或者说实例构造器\<init>() 方法）不同，它不需要显示的调用父类构造器，虚拟机会保证在子类的 \<clinit>() 方法执行之前，父类的 \<clinit>() 方法已经执行完毕。因此虚拟机中第一个被执行的 \<clinit>() 方法的类肯定是 java.lang.Object。
3. 由于父类的 \<clinit>() 方法先执行，也就意味着父类中定义的静态语句块要有限子类的变量赋值操作。
4. \<clinit>() 方法对于接口或类来说并不是必须的，如果一个类中没有静态语句块，也没有为静态变量赋值的操作，那么编译器可以不为这个类生成 \<clinit>() 方法。
5. 接口中不能使用静态代码块，但仍然有变量初始化的赋值操作，因此接口与类一样都会生成 \<clinit>() 方法，但接口与类不同的是，执行接口的     \<clinit>() 方法不需要先执行父接口的 \<clinit>() 方法。只有当父接口中定义的变量使用时，父接口才会初始化。接口的实现类在初始化的时候也不会执行接口的 \<clinit>() 方法。
6. 虚拟机会保证一个类的 \<clinit>() 方法在多线程环境中被正确的加锁、同步，如果多个线程同时去初始化一个类，那么只有一个线程去执行这个类的 \<clinit>() 方法，其他线程都需要阻塞等待。

### 类加载器

类加载器最初是为了 Java applet 的需求开发出来的。后来在类层次划分、OSGi、热部署、代码加密等领域大放异彩。

##### 类与类加载器：

对于任意一个类而言，其唯一性都需要加载这个类的类加载器和这个类本身共同确定。每一个类加载器，都拥有一个独立的类名称空间。比较两个类是否相等（instence 关键字运算的结果）必须是在同一个类加载器加载的前提下才有意义。

##### 双亲委派模型：

- 从Java 虚拟机角度来讲，类加载器分为两种：
  - 启动类加载器（Bootstrap ClassLoader），C++实现的，是虚拟机自身的一部分。
  - 其他的类加载器，由 Java     语言实现，独立于虚拟机外部且都继承自抽象类ClassLoader。
- 3 种系统提供的类加载器：
  - 启动类加载器：负责将放在 <JAVA_HOME>\bin 目录中的或者被     -Xbootclasspath 参数所指定的路径中的且是虚拟机识别的类库加载到虚拟机内存中。使用方式：无法被Java 程序直接引用，在编写类加载器时，需要把加载请求委派给引导类加载器，返回值直接使用 null 代替即可。
  - 扩展类加载器（Extension     ClassLoader）：由 sun.misc.Launcher$ExtClassLoader 实现，负责将     JAVA_HOME\lib\ext 目录中的，或者被java.ext.dirs 系统变量所指定的路径中的所有类库，开发者可以直接使用扩展类加载器。
  - 应用程序类加载器（Application     ClassLoader）：由 AppClassLoader 实现。由于这个类加载器是     ClassLoader 中的 getSystemClassLoader() 方法的返回值，所以一般也称为系统类加载器。负责加载用户类路径上所指定的类库，开发者可以直接使用这个类加载器，如果程序中没有自定义过自己的类加载器，一般情况下这个就是程序默认的类加载器。

- 双亲委派模型：
  - 双亲委派模型除了顶层的启动类加载器外，其余的类加载器都有自己的父类加载器。这里的父子关系一般不会以继承的关系来实现而是以组合的关系来复用父加载器的代码。
  - 工作过程：如果一个类加载器收到了类加载的请求，首先不会自己去尝试加载这个类，而是把这个请求委派给父类加载器去完成，每一层的类加载器都是如此，所以所有的类加载请求启动类加载器都会最先执行加载任务，只有父类加载器反馈无法完成这个加载请求时，子加载器才会尝试自己去加载。
  - 好处：保证类的统一性和唯一性（保证不同的类加载器加载统一个class     文件后得到的是同一个结果。Instanceof 关键字结果为 tru），对于保证 Java     程序的稳定运作很重要。
  - 实现简单：实现双亲委派的代码都集中在     ClassLoader 的 loadClass 方法之中：先调用 findLoadedClass 方法检查是否已经被加载过，没有则调用父加载器的     loadClass 方法，若父加载器为空则默认使用启动类加载器作父类加载器，如果父加载器失败，抛出     ClassNotFoundException 异常后，再调用自己的 findClass 方法进行加载。

### 破坏双亲委派模型：

- JDK 1.2 以后不提倡用户再去覆盖 loadClass 方法，而应当把自己的类加载逻辑写到findClass 方法中。
- 代码热部署、模块热部署。OSGi 已经成为类业界     ”事实上“的Java 模块化标准。
- OSGi 环境下，类加载器不在是双亲委派模型中的树状结构，是一种复杂的网状结构，当收到类加载请求时，OSGi     将按照下面的顺序进行类搜索：
  1. 将以 java.* 开头的类委派给父类加载器加载。
  2. 否则，将委派列表名单内的类派给父类加载器加载。
  3. 否则，将 Import      类表中的类委派给 Export 这个类的 Bundle 的类加载器加载。
  4. 否则，查找当前Bundle 的      ClassPath ， 使用自己的类加载器加载。
  5. 否则，查找类是否在自己的      Fragment Bundle 中，如果在，则委派给 Fragment Bundle 的类加载器加载。
  6. 否则，查找      Dynamic Import 类表的 Bundle，委派给对应 Bundle 的类加载器加载。
  7. 否则，类查找失败。