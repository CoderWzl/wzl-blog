---
title: 虚拟机字节码执行引擎
date: 2021-11-27 12:02:02
permalink: /pages/685e18/
categories:
  - JVM虚拟机专栏
  - 深入理解JVM
tags:
  - 
---
### 运行时栈帧结构

栈帧是用于支持虚拟机进行方法调用和方法执行的数据结构，它是虚拟机运行时数据中的虚拟机栈的元素。

栈帧中存储了方法的局部变量表、操作数栈、动态链接和方法返回地址等信息。

每一个方法从调用开始至执行完成的过程，都对应着一个栈帧从入栈到出栈的过程。

在编译程序代码的时候，栈帧中需要多大的局部变量表、多深的操作数栈都已经完全确定了并且写入到放发表的 Code 属性中，因此一个栈帧需要分配多少内存不会受到程序运行期变量数据的影响，仅仅取决于具体的虚拟机实现。

一个线程中的方法调用链可能会很长，很多方法同时处于执行状态。对于执行引擎来说，在活动线程中，只有位于栈顶的栈帧才是有效的，称为当前栈帧，与之关联的方法称为当前方法。

##### 局部变量表

它是一组变量值存储空间，用于存储方法参数和方法内部定义的局部变量。在 Java 程序编译为 class 文件时，就在方法的 Code 属性中用 max_locals 数据项确定了局部变量表的最大容量。

1. 局部变量表的容量以变量槽 Slot 为最小单位，能存放一个 boolean、byte、char、short、int、float、reference 或 returnAddress 类型的数据。这 8 种数据类型，都可以使用 32 位或更小的物理内存来存放。
2. Reference 类型至少都能通过这个引用做到两点
   - 从引用中直接或间接地查找到对象在 Java 堆中的数据存放的起始地址。
   - 此引用中直接或间接地查找到对象所属数据类型在方法区中的存储的类型信息。
3. 对于64位的数据类型，虚拟机会以高位对其的方式为其分配两个连续的 Slot 空间。
4. 非静态方法中，局部变量表中的第0位索引的 Slot 默认是用于传递方法所属的对象实例引用this。
5. Solt 可以重用。Solt 的复用副作用，直接影响到系统的垃圾回收行为。Solt 中没有被复用，还保留着对象的引用，所以作为 GC Roots 一部分的局部变量表仍然保持着对它的关联。

##### 操作数栈

栈的最大深度在编译的时候写入到 Code 属性的 max_stacks 数据项中。

1. 方法刚执行的时候操作数栈是空的，方法执行的过程中，会有各种字节码指令往操作数栈中写入和提取内容，也就是出栈/入栈操作。
2. Java 虚拟机的解释执行引擎称为“基于栈的执行引擎”，其中所指的栈就是操作数栈。

##### 动态链接

每个栈帧都包含一个指向运行时常量池中该栈帧所属方法的引用，持有这个引用是为了支持方法调用过程中的动态连接。

##### 方法返回地址

一个方法执行后，有两种方式可以退出这个方法。

1. 遇到返回字节码指令，返回数据类型由具体的返回指令确定，称为正常完成出口。
2. 方法执行的过程中遇到了异常，并且这个异常没有在方法体内得到处理。
3. 退出时可能执行的操作有：恢复上层方法的局部变量表和操作数栈，把返回值压入调用者栈帧的操作数栈中，调整 pc     计数器的值以指向方法调用指令后面的一条指令。

### 方法调用

方法调用阶段唯一的任务就是确定被调用方法的版本。

由于动态连接，一切方法调用在 Class 文件里面存储的都只是符号引用，而不是方法在实际运行时内存布局中的入口地址。好处：给 Java     带来了更强大的动态扩展能力，但也使得Java 方法调用过程变得相对复杂起来，需要在类加载期间，甚至到运行期间才能确定目标方法的直接引用。

解析：在类加载的解析阶段，会将其中的一部分引用转化为直接引用，这种解析能成立的前提是：方法在程序真正运行之前就有一个可确定的调用版本，并且这个方法的调用版本在运行期是不可变的。这类方法的调用称为解析。

1. Java 语言中符合“编译器可知，运行期不可变”这个要求的方法，主要包括：静态方法、和私有方法两大类，前者与类型直接关联，后者在外部不可被访问，他们不可能通过继承或别的方式重写其他版本，因此适合在类加载阶段进行解析。
2. 与之相对用的是，在 Java 虚拟机中提供了 5 条方法调用字节码指令
   1. invokestatic：调用静态方法。
   2. invokespecial：调用实例构造器      \<init> 方法、私有方法和父类方法
   3. invokevirtual：调用所有的虚方法。
   4. invokeinterface：调用接口方法，会在运行时确定一个实现类的对象。
   5. invokedynamic：先在运行时动态解析出调用点限定符所引用的方法，然后再执行该方法。
3. 只要能被 invokestatic 和 invokespecial 指令调用的方法，都可以在解析阶段中确定唯一的调用版本，符合这个条件的有静态方法、私有方法、实例构造器、父类方法 4类，他们在类加载的时候就会把符号引用解析为该方法的直接引用。这些方法称为 非虚方法 ，与之相反，其他的方法称为 虚方法（出去final 方法）。
4. Java 中的 非虚方法 除了使用 invokestatic、invokespecial 调用的方法之外还有一种，就是被final 修饰的方法。
5. 解析调用一定是静态的过程，编译期间就能完全确定，而分派调用可能是静态的也可能是动态的，根据分派的宗量可分为单分派和多分派。共 4 种分派方式：静态单分派、静态多分派、动态单分派和动态多分派。

##### 分派

分派调用过程将揭示多态特性的一些最基本的体现，如 重载 和 重写 在 Java 虚拟机中是如何实现的，虚拟机如何确定目标方法的。

1. 静态分派：静态类型或者叫做外观类型（变量声明时变量之前的类型），实际类型（变量应用的实际类型）。

2. 1. 所有依赖静态类型来定位方法执行版本的分派动作称为静态分派。
   2. 静态分派的典型应用是方法重载。静态分派发生在编译阶段，因此确定静态分派的动作实际上不是由虚拟机来执行的。
   3. 很多情况下重载版本不是唯一的，往往只能确定一个更加合适的版本。
   4. 解析与分派这两者之间的关系并不是二选一的排他关系。

3. 动态分派：动态分派过程和多态的另外一个重要的体现-重写有着密切关系。

4. 1. Invokevirtual 指令的运行时解析过程大致分为以下几个步骤：

   2. 1. 找到操作数栈顶的第一个元素所指向的对象的实际类型，记作C
      2. 若在类型 C       中找到与常量中的描述符和简单名称都相符的方法，进行权限校验，通过则返回这个方法的直接引用，查找结束；如果不通过，则返回       IllegalAccessError 异常。
      3. 否则，按照继承关系从下往上依次对 C       的各个父类进行第二步的搜索和验证过程。
      4. 始终没有找到合适的方法，则抛出       AbstractMethodError。

5. 单分派与多分派：方法的接收者与方法的参数统称为方法的宗量，根据分派基于多少种宗量，可以将分派划分为单分派和多分派两种

6. 1. 单分派是根据一个宗量对目标方法进行选择
   2. 多分派则是根据多余一个宗量对目标方法进行选择。
   3. Java      语言的静态分派属于多分派类型。
   4. Java      语言的动态分派属于单分派类型。

##### 虚拟机动态分派的实现

1. 由于动态分派是非常繁琐的动作，而且动态分派的方法版本选择过程需要运行时在类的方法元数据中搜索合适的目标方法，因此在虚拟机的实际实现中基于性能的考虑，大部分实现都不会真正地进行如此频繁的搜索。面对这种情况，最常用的“稳定优化”手段就是为类在方法区中建立一个虚方法表，使用虚方法表索引来代替元数据查找以提高性能。

2. 虚方法表中存放着各个方法的实际入口地址。如果某个方法在子类中没有被重写，那子类的虚方法表里面的地址入口和父类相同方法的地址入口是一致的，都指向父类的实现入口。如果子类中重写了这个方法，子类方法表中的地址将会替换为指向子类实现版本的入口地址。

3. 虚方法表一般在类加载的连接阶段进行初始化，准备了类的变量初始值后，虚拟机会把该类的方法表也初始化完毕。

4. 优化手段还有 内连缓存 和     基于 类型继承关系分析技术的守护内联。

##### 动态类型语言支持

1. 动态类型语言：其关键特征是它的类型检查的主体过程是在运行期而不是编译期。
2. JDK 1.7     与动态类型：invokedynamic，java.lang.invoke 包
3. MethodHandle。

### 基于栈的字节码解释执行引擎

##### 解释执行

在执行前先对程序源码进行词法分析和语法分析处理，把源码转化为抽象语法树。Java 语言中，Javac 编译器完成了程序代码经过词法分析、语法分析到抽象语法树，再遍历语法树生成线性的字节码指令流的过程。因为这一部分动作是在Java 虚拟机之外进行的，而解释器在虚拟机的内部，所以 Java 程序的编译就是半独立的实现。

##### 基于栈的指令集与基于寄存器的指令集

1. Java 编译器输出的指令流，基本上是一种基于栈的指令集架构，指令流中的指令大部分都是零地址指令，他们依赖操作数栈进行工作。基于寄存器的指令集主流pc 支持的指令集。

2. 基于栈的指令集和基于寄存器的指令集的区别：

3. 两种指令集的优缺点：

4. 1. 栈：可移植性高，寄存器受硬件的影响。代码相对更加紧凑、编译器实现更加简单；执行速度稍慢
   2. 寄存器：执行速度快
   3. 虽然栈架构指令集的代码非常紧凑，但是完成相同的功能所需的指令数量一般会比寄存器架构多，因为入栈出栈操作本身就产生了相当多的指令数量。
   4. 栈实现在内存之中，会频繁的内存访问，相对于处理器来说，内存始终是执行速度的瓶颈。
