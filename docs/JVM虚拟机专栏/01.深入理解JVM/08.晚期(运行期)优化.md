---
title: 晚期(运行期)优化
date: 2021-12-11 11:59:08
permalink: /pages/ff3ab0/
categories:
  - JVM虚拟机专栏
  - 深入理解JVM
tags:
  - 
---
### 概述

当虚拟机发现某个方法或代码块运行的特别频繁时，就把这些代码认定为“热点代码”。为了执行效率，在运行时虚拟机会把这些代码编译成与本地平台相关的机器码，进行各种层次的优化，完成这个任务的编译器称为即时编译器（Just In Time Compiler，JIT 编译器）。

### Hotspot 虚拟机内的即时编译器

为什么 Hotspot 虚拟机要使用解释器与编译器并存的架构

##### 解释器与编译器各有优势：

1. 程序需要迅速启动的时候，解释器首先发挥作用，省去编译的时间，立即执行。
2. 执行后把较多的代码逐渐编译为本地代码，可以获得更高的执行效率。
3. 程序运行环境中内存资源限制较大，可以使用解释执行节约内存，反之可以编译执行提升效率。

Hotspot 虚拟机还会逐渐启用分层编译的策略。

1. 第0层，程序解释执行，解释器不开启性能监控功能，可触发 1 层编译
2. 第1层，也称为 C1 编译，将字节码编译为本地代码，进行简单、可靠的优化、如果有必要将加入性能监控的逻辑。
3. 第2层，也称为 C2 编译，将字节码编译为本地代码，但是会启用一些耗时较长的优化，甚至会根据性能监控信息进行一些不可靠的激进优化。

##### 编译对象与触发条件

1. 热点代码有两类：
   1. 被多次调用的方法
   2. 被多次执行的循环体

2. 第一种情况当然会以整个方法作为编译对象。第二种情况虽然编译动作是由循环体所触发的，但编译器依然会以整个方法作为编译器对象，因为编译发生在方法的执行过程中，因此也被形象的称为栈上替换，简称 OSR 编译。判断一段代码是不是热点代码的行为称为热点探测，热点探测的方式主要有两种：
   1. 基于采样的热点探测
   2. 基于计数器的热点探测（Hotspot 虚拟机中使用的方法）

3. 方法调用计数器统计的并不是方法被调用的绝对次数，而是一个相对的执行频率，即一段时间之内方法被调用的次数。当超过一定时间限度，如果方法的调用次数仍然不足以让它提交给即时编译器编译，那么这个方法的调用计数器就会被减少一半，这个过程称为方法调用计数器热度的衰减。
4. 回边计数器，它的作用是统计一个方法中循环体代码的执行的次数，为了触发 OSR 编译，没有热度衰减。

##### 编译过程

Server Compiler 和 Client Complier 两个编译器的编译过程是不一样的。对于 Client Complier 来说，他是一个简单快速的三段式编译器，主要的关注点在于局部性的优化，而放弃了许多耗时较长的全局优化手段。

1. 第一阶段，一个平台独立的前端将字节码构造成一种高级中间代码表示（HIR），HIR 使用静态单分配的形式来代表代码值，这使得一些在 HIR 的构造过程中和之后的优化动作更容易实现。在此之前便会在字节码上完成一部分基础优化，如方法内联、常量传播等优化将会在字节码被构造成 HIR 之前完成。
2. 第二阶段，一个平台相关的后端从 HIR 中产生低级中间代码表示（LIR），而在此之前会在 HIR 上完成另一些优化，如空值检查消除，范围检查消除等，以便让 HIR 达到更高效的代码表示形式。
3. 最后一个阶段，在平台相关的后端使用线性扫描算法在 LIR 上分配寄存器，并在 LIR 上做窥孔优化，然后产生机器代码。

Server Complier 是专门面向服务端的典型应用。

##### 查看及分析即时编译结果

### 编译优化技术

优化技术有很多，重点介绍其中的一部分，他们分别是：1、语言无关的经典优化技术之一：公共子表达式消除；2、语言相关的经典优化技术之一：数组范围检查消除；3、重要的优化技术之一：方法内联；4、最前沿的优化技术之一：逃逸分析。

##### 公共子表达式消除

如果一个表达式 E 已经计算过了，并且从先前的计算到现在 E 中所有变量的值都没有发生变化，那么 E 的这次出现就成为了公共子表达式。这个表达式不用再计算了可以直接使用之前计算的值直接代替。

##### 数组边界检查消除

##### 方法内联

它是编译器最重要的优化手段之一，除了消除方法调用的成本之外，它更重要的意义是为其他优化手段建立良好的基础。

##### 逃逸分析

它与类型继承关系分析一样，并不是直接优化代码的手段，而是为其他优化手段提供依据的分析技术。

逃逸分析的基本行为就是分析对象动态作用域：当一个对象在方法中被定义后，它可能被外部方法所引用，例如作为调用参数传递到其他方法中，称为方法逃逸。甚至还有可能被外部线程访问到，譬如复制给变量或可以在其他线程中访问的实例变量，称为线程逃逸。

如果能证明一个对象不会逃逸到方法或线程之外，也就是别的方法或线程无法通过任何途径访问到这个对象，则可能为这个变量进行一些高效的优化。

1. 栈上分配：虚拟机中堆上分配创建对象的内存空间常识，堆中的对象对于各个线程都是共享和可见的，只要持有这个对象的引用，就可以访问堆中存储的对象数据。回收堆中的内存无论是筛选可回收对象，还是回收和整理内存都需要耗费时间。对象在栈上分配内存的话就会随方法执行入栈和出栈不用耗时回收
2. 同步消除：线程同步本来就是一个相对耗时的过程，如果逃逸分析能够确定一个变量不会逃逸出线程，无法被其他线程访问，那么这个变量的读写肯定不会有竞争，这个变量实施的同步措施也就可以被消除掉。
3. 标量替换：标量（Scalar）是指一个数据已经无法再分解成更小的数据来表示了，Java     中的原始数据类型都不能再进一步分解，他们可以称为标量，相对的如果一个数据可以继续分解，那它就称做聚合量，Java     中的对象就是最典型的聚合量。如果能够把一个Java 对象拆散，根据程序访问的情况将其使用到的成员变量恢复原始类型来访问就叫做标量替换，除了可以让成员变量在栈上分配和读写之外，还可以为后续进一步的优化手段创建条件。

### Java 与 C/C++ 的编译器对比(Java 即时编译器的劣势)

1. 即时编译器运行占用的是用户程序的运行时间，具有很大的压力，他能提供的优化手段也严重受限于编译成本。
2. Java 是动态的类型安全语言，意味着需要有虚拟机来确保程序不会违反语言语义或访问非结构化内存。
3. Java 语言中虽然没有 virtual 关键字，但使用虚方法的频率却远大于 C/C++ 语言，意味着运行时对方法接收者进行多态选择的频率要远大于 C/C++ 语言，即时编译器在进行一些优化时的难度要远大于 C/C++ 的静态优化编译器。
4. Java 语言是可以动态扩展的语言，运行时加载新的类可能改变程序类型的继承关系，这使得很多全局的优化都难以进行，因为编译器无法看见程序的全貌，许多全局的优化措施都只能以激进优化的方式来完成，编译器不得不时刻关注并随着类型的变化而在运行时撤销或重新进行一些优化。
5. Java 中对象的内存分配都是在堆上进行的，只有方法中的局部变量才能在栈上分配。