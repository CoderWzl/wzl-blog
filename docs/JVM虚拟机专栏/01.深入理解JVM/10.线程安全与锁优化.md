---
title: 线程安全与锁优化
date: 2021-12-25 16:32:00
permalink: /pages/5eb56b/
categories:
  - JVM虚拟机专栏
  - 深入理解JVM
tags:
  - 
---
### 概述

线程安全：如果一个对象可以安全的被多个线程使用，那么它就是线程安全的。

##### Java 语言中的线程安全：

多线程共享数据是前提，‘安全程度’的划分，Java 中各种操作共享数据分为以下5类：不可变，绝对线程安全，相对线程安全，线程兼容和线程对立。

- 不可变：不可变的对象一定是线程安全的，final 关键字带来的可见性。Java 语言中如果共享数据是基本数据类型，那么只要定义时使用 final 关键字修饰它就可以保证它是不可变的。如果共享数据是一个对象，那么就要保证对象的行为不会对其状态产生任何影响才行。String 是一个典型的不可变对象，还有枚举，以及 java.lang.Number 的部分子类。
- 绝对线程安全
- 相对线程安全：就是通常意义说的线程安全，它需要保证对这个对象的单独操作是线程安全的。Java 语言中大部分的线程安全类都属于这种类型，例如 Vector，HashTable ...
- 线程兼容：指对象本身并不是线程安全的，但是可以通过在调用端正确的同步手段来保证对象在并发环境中可以安全的使用。
- 线程对立：无论调用端是否采取了同步措施，都无法在多线程中并发使用的代码。Thread 的 suspend 和 resume 方法就是线程对立的例子。

##### 线程安全的实现方法：

了解了什么是线程安全之后，紧接着的问题就是我们应该如何实现线程安全。

- 互斥同步：一种常见的并发正确性保障手段。同步是指在多个线程并发访问共享数据时，保证共享数据在同一时刻只被一个线程使用。而互斥是实现同步的一种手段，邻界区，互斥量和信号量都是主要的互斥实现方式。在Java 中，最基本的互斥同步手段就是 synchrinized 关键字，其经过编译后，在同步块的前后分别形成 monitorenter 和 monitorexit 这两个字节码指令，这两个字节码都需要一个 reference 类型的参数来指明要锁定和解锁的对象。如果 Java 程序中的 synchronized 明确指定了对象参数，那就是这个对象的 reference；如果没有明确指定，那就根据 synchronized 修饰的是实例方法还是类方法，去取对应的对象实例或 Class 对象来作为锁对象。虚拟机规范要求，在执行 monitorenter 指令时，首先要尝试获取对象的锁。如果这个对象没有被锁定，或者当前线程已经拥有了那个对象的锁，把锁的计数器加 1 ，相应的，在执行 monitorexit 指令时会将锁计数器减 1，当计数器为 0 时，锁就被释放。如果获取对象锁失败，那当前线程就要阻塞等待，直到对象锁被另外一个线程释放为止。

  在虚拟机规范对 monitorenter 和 monitorexit 的行为描述中，有两点需要特别注意的。

  - synchronized 同步块对同一线程是可重入的，不会出现自己吧自己锁死的问题。
  - 同步块在已进入的线程执行完之前，会阻塞后面其他线程的进入。

  Java 的线程是映射到操作系统的原生线程之上的，如果要阻塞或唤醒一个线程，都需要操作系统来帮忙完成，这就需要从用户态转换到核心态中，因此状态转换需要耗费很多的处理器时间。Synchronized 是 Java 语言中一个重量级的操作。

  除了 synchronized 之外，我们还可以使用 java.util.concurrent 包中的重入锁（ReentrantLock）来实现同步，在基本的使用上与 synchronized 很相似。提供了一些高级功能，主要有以下三项：等待可中断，可实现公平锁，以及锁可以绑定多个条件。

  - 等待可中断是指当持有锁的线程长期不释放锁的时候，正在等待的线程可以选择放弃等待，改为处理其他事情，可中断特性对处理执行时间非常长的同步块很有帮助。
  - 公平锁是指多个线程 在等待同一个锁时，必须按照申请的时间顺序来依次获得锁；而非公平锁则不保证这一点，在锁被释放时，任何一个等待锁的线程都有机会获得锁。 Synchronized 中的锁是非公平的， ReentrantLock 默认情况下也是非常公平的，当可以通过带 boolean 的构造函数要求使用公平锁。
  - 锁绑定多个条件是指一个 ReetrantLock 对象可以同时绑定多个 Condition 对象，而在 synchronized 中，锁对象的 wait 和 notify 或 notifyAll 方法可以实现一个隐含的条件，如果要和多于一个的条件关联的时候，就不得不额外的添加一个锁，而 ReentrantLock 无需这样做，只需要多次调用 newCondition 方法即可。

  两者性能对比：jdk 1.6 之前 ReetrantLock 性能高于 synchronized 高并发的情况下有稳定的吞吐量，jdk 1.6 之后两者基本持平。在两种同步的选择上，优先考虑使用 synchronized 来进行同步，除非要用到 ReetrantLock 上述特性的时候需要使用该同步方式。

- 非阻塞同步：

  互斥同步主要的问题就是进行线程阻塞和唤醒所带来的性能问题，因此这种同步也称为阻塞同步。悲观的并发策略。

  非阻塞同步需要硬件指令集的支持，基于冲突检测的乐观并发策略，通俗的说就是先进行操作，如果没有其他线程争用共享数据，那操作就成功了；如果共享数据有竞争，产生了冲突，那就采取其他的补偿措施，这种乐观的并发策略的许多实现都不需要吧线程挂起。

  为什么需要硬件指令集的保证呢？因为我们需要操作和冲突检测这两个步骤具备原子性，硬件保证一个从语义上看起来需要多次操作的行为只通过一条处理器指令就能完成，这类指令有：

  1. 测试并设置（Test-and-Set）
  2. 获取并增加（Fetch-and-Increment）
  3. 交换（Swap）
  4. 比较并交换（Compare-and-Swap，CAS）
  5. 加载链接/条件存储（Load-Linked/Store-Conditional，LL/SC）

  Java 语言中 jdk 1.5 以后才可以使用 CAS 操作 AtomicInteger 等类可以实现 CAS 操作，ABA 问题，虽然经过操作 变量的值没有改变，但是不能保证在操作过程中发生了改变然后又变了回来。虽然‘AtomicStampedReference’解决了这个问题，但是如果要解决 ABA 问题，该用传统的互斥同步可能会比原子类更高效。

- 无同步方案：

  要保证线程安全，不是一定要进行同步，两者没有因果关系。同步只是保证共享数据争用时的正确性手段，如果一个方法本来就不涉及共享数据，一些代码天生是线程安全的。

  1. 可重入代码：所有可重入代码都是线程安全的，又叫做纯代码。判断可重入代码：如果一个方法，它的返回结果是可以预测的，只要输入了相同的数据，就能返回相同的结果，那就满足可重入性要求，自然是线程安全的。
  2. 线程本地存储：ThreadLocal     类来实现线程本地存储的功能。

### 锁优化

锁优化技术有：适应性自旋，锁消除，锁粗化，轻量级锁和偏向锁等，这些技术都是为了在线程之间更高效地共享数据，以及解决竞争问题，从而提高程序的执行效率。

##### 自旋锁与自适应自旋

许多应用上，共享数据的锁定状态只会持续很短的一段时间，为了这段时间去挂起和恢复线程并不值得。如果物理机器有一个以上的处理器，能让两个或以上的线程同时并行执行，我们就可以让后面的线程“稍微等一下”，但不放弃处理器的执行时间，看看持有锁的线程是否很快就会释放。为了让线程等待，我们只需要让线程执行一个忙循环（自旋），这项技术就是所谓的自旋锁。

如果锁被占用的时间很短，自旋等待的效果就会非常好，反之被占用的时间很长的话就会白白消耗处理器资源，带来性能上的浪费。自旋次数加以限制，超过次数限制还没有完成，那么应当使用传统的方式去挂起线程了。自旋的次数默认值是 10 次。

Jdk 1.6 引入了自适应的自旋锁。自旋的时间不在固定了，而是由前一次在同一个锁上的自旋时间以及锁拥有者的状态来决定。

##### 锁消除

锁消除是指虚拟机即使编译器在运行时，对一些代码上要求同步，但是检测到不可能存在共享数据竞争的锁进行消除。锁消除的主要判断依据来源于逃逸分析的数据支持，如果判断在一段代码中，堆上的所有数据都不会逃逸出去从而被其他线程访问到，那就可以把它们当作栈上数据对待，认为它们是线程私有的，同步加锁自然就无需进行。

程序编写者很清楚什么时候需要加锁，为什么还要进行锁消除优化呢？

因为很多时候加锁不是程序员添加的，而是 api 中的代码中添加的，程序编写者无法干涉，如 StringBuffer 的 append 操作，就是用 synchronized 关键字修饰的，而使用该操作的时候很有可能，不存在对 StringBuffer 该对象的竞争。

发生在 即时编译 阶段

##### 锁粗化

原则上，应该将同步块的作用范围限制的尽量小--只是在共享数据的实际作用域中才进行同步。但是在连续的操作都对同一个对象反复加锁和解锁，甚至是出现在循环体中，如 StringBuffer 连续的 append 操作。应该对锁进行粗化。

##### 轻量级锁

轻量级锁不是用来代替重量级锁（使用操作系统互斥量来实现的传统锁）的，它的本意是在没有线程竞争的前提下，减少传统的重量级锁使用操作系统互斥量产生的性能消耗。

要理解轻量级锁及偏向锁，需要从 HotSport 虚拟机的对象（对象头）的内存布局开始介绍。对象头分为两部分信息，第一部分用于存储对象自身运行时数据，如 hashCode，GC 分代年龄等，长度在 32 位和 64 位虚拟机中分别为 32 位和 64 位，官方称为MarkWord ，它是实现轻量级锁和偏向锁的关键。另外一部分用于存储指向方法区对象类型数据的指针，如果是数组的话，还会有额外的部分用于存储数组的长度。

MarkWord 被设计成一个非固定的数据结构以便节省空间，在极小的空间内存储尽量多的信息，它会根据自己的状态复用自己的存储空间。如在 32 位虚拟机中对象为被锁定的状态下，MarkWord 的 32 bit 空间中 25 bit 用于存储对象 hashCode，4 bit 用于存储对象分代年龄，2 bit 用于存储锁标志位，1 bit 固定为0，其他状态（轻量级锁，重量级锁，GC 标记，可偏向）下对象的存储内容如下

| 存储内容                              | 标志位 | 状态               |
| ------------------------------------- | ------ | ------------------ |
| 对象哈希吗，对象分代年龄              | 01     | 未锁定             |
| 指向锁记录的指针                      | 00     | 轻量级锁定         |
| 指向重量级锁的指针                    | 10     | 膨胀（重量级锁定） |
| 空，不需要记录信息                    | 11     | GC 标记            |
| 偏向线程 ID，偏向时间戳，对象分代年龄 | 01     | 可偏向             |

代码进入同步块的时候，如果此同步对象没有被锁定（01），虚拟机首先将在当前线程的栈帧中建立一个名为锁记录（Lock Record）的空间，用于存储锁对象目前的 MarkWord 的拷贝；然后虚拟机使用 CAS 操作尝试将对象的 MarkWord 更新为指向 Lock Record 的指针。操作成功了，这个线程就拥有了该对象的锁，并且对象 MarkWord 的锁标志位 将转换为 00 表示该对象处于轻量级锁定状态。如果这个操作失败了，虚拟机检查对象的 MarkWord 是否指向当前线程的栈帧，如果是说明当前线程已经拥有了这个对象的锁，就可以直接进入同步块继续执行，否则说明这个锁对象被其他线程占用了。如果有两条以上的线程争用同一个锁，那轻量级锁就不在有效，要膨胀为重量级锁，锁标志为 10 ， MarkWord 中存储的就是指向重量级锁（互斥量）的指针，后面等待锁的线程也要进入阻塞状态。

解锁的状态使用 CAS 操作将栈帧中存储对象的原来的 MarkWord 和对象当前的 MK 进行替换，替换成功整个同步过程就完成了。替换失败，说明有其他线程尝试获取该锁，那就要在释放锁的同时，唤醒被挂起的线程。

其提升性能的依据是 ‘对于绝大部份的锁，整个同步周期内都是不存在竞争的’，在存在竞争的情况下除了互斥量的开销，而外增加了 CAS 操作，因此会更慢。

##### 偏向锁

目的是显出数据在无竞争情况下的同步，进一步提高程序的运行性能。偏向锁在无竞争的情况下把整个同步都消除了，连 CAS 操作也不做了。

它会偏向于第一个获得它的线程，如果在接下来的执行过程中，该锁没有被其他的线程获取，则持有偏向锁的线程将永远不需要在进行同步。

虚拟机启用了偏向锁，那么当锁对象第一次被线程获取的时候，虚拟机将会把对象头中的标志位设为 01 ，即偏向模式。同时使用 CAS 操作把获取到这个锁线程的ID 记录在MarkWord 中，如果CAS 操作成功，持有偏向锁的线程以后每次进入这个锁相关的同步块时，虚拟机都可以不在进行任何同步操作。

当有另一个线程去尝试获取这个锁时，偏向模式就宣告结束。根据锁对象目前是否处于被锁定的状态，撤销偏向后恢复到未锁定或轻量级锁定的状态，后面的操作就是轻量级锁的操作了。

偏向锁可以提高带有同步但无竞争的程序性能，但是当程序中大多数的锁总是被多个不同的线程访问，那么偏向模式就是多余的。